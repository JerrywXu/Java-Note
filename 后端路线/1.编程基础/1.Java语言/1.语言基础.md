# 1.接口

在接口里面定义一个抽象方法

```java
//创建一接口
package a;//创建一个包，名字为a
public interface aaa1
{
	public int getMax();//创建一个接口方法getMax,都是出现方法需要实现接口然后重写
	String getMes();//创建一个接口方法getMex
}
```

```java
package a;//创建一个包，名字为a
//开发使用该接口的类
import a.aaa1;//引用接口的包
public class test implements aaa1 //test类描述的是实现接口的方法
{
	public int getMax()//实现接口里的方法
	{
		int i=123;
		return i;
	}
	public String getMes()//实现接口里的方法
	{
		String s="实现接口里的方法";
		return s;
	}
	public static void main (String[]args)
	{
		test t=new test();//创建test类的实例对象
		int i=t.getMax();//实现了接口里的方法并进行调用
		String s=t.getMes();
		System.out.println(i);
		System.out.println(s);
	}

}


```

# 2.容器总结(集合)





![img](file://D:\LocalRepositories\OriginRepositories\JavaNote\%E5%90%8E%E7%AB%AF%E8%B7%AF%E7%BA%BF\1.%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80\1.Java%E8%AF%AD%E8%A8%80\img\20190213131312518.png?lastModify=1627637177)

<img src="img/image-20210730174352638.png" alt="image-20210730174352638" style="zoom:80%;" />



## 一、Collection

<img src="img/1628e4e1f75125d8" alt="img" style="zoom: 67%;" />

### 1、迭代器(Iterator)介绍

**遍历集合(Collection)的元素都可以使用Iterator**，至于它的具体实现是以内部类的方式实现的！

```java
  hasNext()、next()、remove()

  hasNext:没有指针下移操作，只是判断是否存在下一个元素

  next:指针下移，返回该指针所指向的元素

  remove:删除当前指针所指向的元素，一般和next方法一起用，这时候的作用就是删除next方法返回的元素
      
  nextLine():不会忽略一些字符如空格等。
  next():会忽略一些字符，只记录有效字符。

```



<img src="img/1628e4e2686de25a" alt="img" style="zoom:150%;" />

### 2、List与Set常用子类及介绍

**List集合常用的子类有三个：**

•      ArrayList

–     底层数据结构是数组。线程不安全

•      LinkedList

–     底层数据结构是链表。线程不安全

•      Vector

–     底层数据结构是数组。线程安全



 **Set集合的特点是：元素不可重复，常用子类有**

•      HashSet集合

–     A:底层数据结构是哈希表(是一个元素为链表的数组) 

•      TreeSet集合

–     A:底层数据结构是红黑树(是一个自平衡的二叉树)

–     B:保证元素的排序方式

•      LinkedHashSet集合 

–     A:：底层数据结构由哈希表和链表组成。



## 二、List集合

### 1、ArrayList解析

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image056.jpg?lastModify=1629799861)

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image058.jpg?lastModify=1629799933)

#### 1.1构造方法

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image060.jpg?lastModify=1629801960)

#### 1.2add方法

**add(E e)**

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image062.jpg?lastModify=1629873205)

•      **确认list容量，尝试容量加1，看看有无必要**

•      **添加元素**

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image064.jpg?lastModify=1629874010)

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image066.jpg?lastModify=1629874023)

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image068.jpg?lastModify=1629874040)

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image070.jpg?lastModify=1629874054)

到目前为止，我们就可以知道add(E e)的基本实现了：

•      首先去检查一下数组的容量是否足够

–     足够：直接添加

–     不足够：扩容

•      扩容到原来的1.5倍

•      第一次扩容后，如果容量还是小于minCapacity，就将容量扩充为minCapacity。



**add(int index, E element)**

步骤：

•      **检查角标**

•      **空间检查，如果有需要进行扩容**

•      **插入元素**

![标题: fig:](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image072.png?lastModify=1629874258)

我们发现，与扩容相关ArrayList的add方法底层其实都是arraycopy()来实现的

看到arraycopy()，我们可以发现：该方法是由C/C++来编写的，并不是由Java实现：

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image074.jpg?lastModify=1629874319)

本地Native方法非常有用，因为它有效地扩充了jvm.事实上，我们所写的java代码已经用到了本地方法，在sun的java的并发（多线程）的机制实现中，许多与操作系统的接触点都用到了本地方法，这使得java程序能够超越java运行时的界限。有了本地方法，java程序可以做任何应用层次的任务。

#### 1.3get方法

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image076.jpg?lastModify=1629874393)



```java
 //检查角标
 private void rangeCheck(int index) {
  if (index >= size)
   throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
 }

 //返回元素
 E elementData(int index) {
  return (E) elementData[index];
 }
```

#### 1.4set方法

​				•      **检查角标**

​				•      **替代元素**

​				•      **返回旧值**

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image078.jpg?lastModify=1629874628)

#### 1.5remove方法

•      **检查角标**

•      **删除元素**

•      **计算出需要移动的个数，并移动**

•      **设置为null，让Gc回收**

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image080.jpg?lastModify=1629874713)



#### 1.6其他一些细节

•      ArrayList是**基于动态数组实现的**，在**增删时候，需要数组的拷贝复制**。

•      ArrayList的默认初始化容量是10，每次扩容时候增加原先容量的一半，也就是变为原来的1.5**倍**

•      删除元素时不会减少容量，**若希望减少容量则调用trimToSize()**。

•      它不是线程安全的。它能存放null值。

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image082.jpg?lastModify=1629875006)

### 2、Vector vs ArrayList?

Vector是jdk1.2的类了，比较老旧的一个集合类。

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image085.jpg?lastModify=1629876238)

Vector底层也是数组，与ArrayList最大的区别就是：**同步(线程安全)**

Vector是同步的，我们可以从方法上就可以看得出来~

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image087.jpg?lastModify=1629876601)

在要求非同步的情况下，我们一般都是使用ArrayList来替代Vector的了~

如果想要ArrayList实现同步，可以使用Collections的方法：**List list = Collections.synchronizedList(new ArrayList(...));**就可以实现同步了~

还有另一个区别：

•      **ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector是扩展1倍。**

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image089.jpg?lastModify=1629876661)

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image091.jpg?lastModify=1629876668)

### 3、LinkedList解析

LinkedList底层是**双向链表**

单向链表：只有一个指向下一个节点的指针。

优点：单向链表增加删除节点简单。遍历时候不会死循环；

缺点：只能从头到尾遍历。只能找到后继，无法找到前驱，也就是只能前进。

适用于节点的增加删除。

 

双向链表：有两个指针，一个指向前一个节点，一个后一个节点。

优点：可以找到前驱和后继，可进可退；

缺点：增加删除节点复杂，需要多分配一个指针存储空间。

适用于需要双向查找节点值的情况。


![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image093.jpg?lastModify=1629876702)

从结构上，我们还看到了**LinkedList**实现了Deque接口，因此，我们可以操作LinkedList像操作队列和栈一样~

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image096.png?lastModify=1629877423)

LinkedList变量就这么几个，因为我们操作单向链表的时候也发现了：有了头结点，其他的数据我们都可以获取得到了。(双向链表也同理)

#### 3.1构造方法

构造方法有两个：

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image100.jpg?lastModify=1629877643)

#### 3.2add方法

```java
//add方法实际上就是往链表最后添加元素

   public boolean add(E e) {
     linkLast(e);
     return true;
   }
   void linkLast(E e) {
     final Node<E> l = last;
     final Node<E> newNode = new Node<>(l, e, null);
     last = newNode;
     if (l == null)
       first = newNode;
     else
       l.next = newNode;
     size++;
     modCount++;
   }
```

#### 3.3get方法

我们进去看一下具体的实现是怎么样的：

可以看到get方法实现就两段代码：

```java
 public E get(int index) {
     checkElementIndex(index);
     return node(index).item;
   }
```

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image108.jpg?lastModify=1629878494)



#### 3.4set方法

```java
//set方法和get方法其实差不多，**根据下标来判断是从头遍历还是从尾遍历**

  public E set(int index, E element) {
     checkElementIndex(index);
     Node<E> x = node(index);
     E oldVal = x.item;
     x.item = element;
     return oldVal;
   }
```



#### 3.5remove方法

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image102.jpg?lastModify=1629877892)`

<img src="file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image104.jpg?lastModify=1629877932" alt="img" style="zoom:67%;" />

<img src="file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image106.jpg?lastModify=1629877853" alt="img" style="zoom:67%;" />





### 4、List集合总结

**ArrayList**：

•      底层实现是数组

•      ArrayList的默认初始化容量是10，每次扩容时候增加原先容量的一半，也就是变为原来的1.5倍

•      在**增删时候，需要数组的拷贝复制(navite 方法由C/C++实现)**

**LinkedList**：

•      底层实现是**双向链表**[双向链表方便实现往前遍历

**Vector**：

•      底层是数组，现在已少用，被ArrayList替代，原因有两个：

–     Vector所有方法都是同步，**有性能损失**。

–     Vector初始length是10 超过length时 以100%比率增长，**相比于ArrayList更多消耗内存**。

**总的来说：查询多用ArrayList，增删多用LinkedList**。

**ArrayList**增删慢不是绝对的(在数量大的情况下，已测试)：

•      如果增加元素一直是使用add()(增加到末尾)的话，那是ArrayList要快

•      一直删除末尾的元素也是ArrayList要快【不用复制移动位置】

•      至于如果删除的是中间的位置的话，还是ArrayList！

但一般来说：**增删多还是用LinkedList**，因为上面的情况是极端的~



## 三、Map集合

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image115.jpg?lastModify=1629888353)

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image119.jpg?lastModify=1629888385)

**Map的子类**

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image121.jpg?lastModify=1629888457)



### 1.散列表（Hash表）

散列表为每个对象计算出一个整数，称为散列码。根据这些计算出来的整数(散列码)保存在对应的位置上！

在Java中，散列表用的是链表数组实现的，每个列表称之为桶。

一个桶上可能会遇到被占用的情况(hashCode散列码相同，就存储在同一个位置上)，这种情况是无法避免的，这种现象称之为：散列冲突

•      此时需要**用该对象与桶上的对象进行比较，看看该对象是否存在桶子上了**~如果存在，就不添加了，如果不存在则添加到桶子上

•      当然了，如果hashcode函数设计得足够好，桶的数目也足够，这种比较是很少的~

•      在**JDK1.8**中，**桶满时**会从**链表变成红黑树**

​        如果散列表太满，**是需要对散列表再散列，创建一个桶数更多的散列表，并将原有的元素插入到新表中，丢弃原来的表**

•      装填因子(load factor)**决定了何时**对散列表再散列~

•      装填因子默认为0.75，如果表中**超过了75%**的位置已经填入了元素，那么这个表就会用**双倍的桶数**自动进行再散列。



解释的是最常用的一种方法——拉链法，我们可以理解为“链表的数组”，如图：

![img](img/20160603152626346)

​                                                                                         hash表的应用（拉链法）

解决散列冲突通常有以下几种方法：

- 拉链法

- 开放定址法

  **线性探测法**

  如果此时再要插入20，则20 % 7 = 6，但是6的位置已有元素，因此探测下一个位置（6+1）%7，在这里就是下标为0的位置。但这种方式的一个问题是，可能造成**一次聚集**，因为一旦冲突发生，为了处理冲突就会占用下一个位置，而如果冲突较多时，就会出现数据都**聚集在一块区域**。这样就会导致任何关键字都需要多次尝试才可能解决冲突。

  

  **平方探测法**

  顾名思义，如果说前面的探测函数是F（i）= i % 7，那么平方探测法就是F（i）= (i^2 )% 7。但是这也同样会产生**二次聚集**问题。
  
  
  
  **双散列**
  
  为了避免聚集，在探测时选择跳跃式的探测，即再使用一个散列函数，用来计算探测的位置。假设前面的散列函数为hash1(X)，用于探测的散列函数为hash2(X)，那么一种流行的选择是F(i) = i * hash2(X)，即第一次冲突时探测hash1(X)+hash2(X)的位置，第二次探测
  hash1(X)+2hash2(X)的位置。可以看到，无论是哪种开放定址法，它都要求表足够大。
  
  
  
  **再散列**
  
  散列表可以认为是具有固定大小的数组，那么如果插入新的数据时散列表已满，或者散列表所剩容量不多该怎么办？这个时候就需要再散列，常见做法是，建立一个是原来两倍大小的散列表，将原来表中的关键字重新散列到新表中。

**散列表的应用**

​        文件校验或数字签名。当然还有快速查询功能的实现。例如，redis中的字典结构就使用了散列表，使用**MurmurHash算法**来计算字符串的hash值，并采用**拉链法**处理冲突，当散列表的**装载因子**（关键字个数与散列表大小的比）接近某个大小时，进行**再散列**。一个设计良好的散列表能够几乎在O（1）时间复杂度内完成插入，删除和查找，但前提是**散列函数设计得足够优雅，以及有着合适散列冲突解决方案**。



**重写equal需要重写hashcode方法？**

​		假如只重写equals而不重写hashcode，那么Student类的hashcode方法就是Object默认的hashcode方法，由于默认的hashcode方法是根据对象的内存地址经哈希算法得来的，显然此时s1!=s2,故两者的hashcode不一定相等。然而重写了equals，且s1.equals(s2)返回true，根据hashcode的规则，两个对象相等其哈希值一定相等，所以矛盾就产生了，因此重写equals一定要重写hashcode，而且从Student类重写后的hashcode方法中可以看出，重写后返回的新的哈希值与Student的两个属性有关。hashcode的值与类中的具体属性有关。



以下是关于hashcode的一些规定：

两个对象相等，hashcode一定相等
两个对象不等，hashcode不一定不等
hashcode相等，两个对象不一定相等
hashcode不等，两个对象一定不等

### 2.红黑树

**2-3树可以了解一下**

![img](file://D:/LocalRepositories/OriginRepositories/JavaNote/%E5%90%8E%E7%AB%AF%E8%B7%AF%E7%BA%BF/1.%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/1.Java%E8%AF%AD%E8%A8%80/img/v2-d5273c0d3dd4659cc621c8461ee3879c_r.jpg?lastModify=1629989215)

![img](img/20190514220736591.png)

AVL 树是又叫平衡二叉树，平衡二叉树递归定义如下：

1. 左右子树的高度差小于等于 1。

2. 其每一个子树均为平衡二叉树。

AVL树的左旋与右旋 https://blog.csdn.net/qq_25806863/article/details/74755131



![img](file://D:\FolkKnowledge\Company_interview_question\Question\img\clipboard-1614080911857.png?lastModify=1627628727)

但是红黑树的性质是每条路径的黑色节点数目相同这个时候你再想想那其他路径的黑色节点数目一定比你现在少一个节点，所以调整起来是非常繁琐的. 插入红节点不需要调整其他路径，如果它的父亲为黑，那么直接插入，如果他的父亲为红那么在该路径上面开始分情况调整. 所以插入节点默认颜色一定要为红.如果为黑调节成本太大了.



## 四、HashMap

### 1.HashMap刨析

<img src="file://C:/Users/%E5%BE%90%E7%BA%AA%E4%BC%9F/Desktop/img/clip_image142.jpg?lastModify=1630029320" alt="img" style="zoom:150%;" />

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image144.jpg?lastModify=1630029394)

HashMap属性

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image146.jpg?lastModify=1630029488)

具体方法

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image148.jpg?lastModify=1630029587)



#### 1.1HashMap构造方法

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image154.jpg?lastModify=1630030464)

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image156.jpg?lastModify=1630030617)

在上面的构造方法最后一行，我们会发现调用了tableSizeFor()，我们进去看看：

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image158.jpg?lastModify=1630030734)

看完上面可能会感到奇怪的是：**为啥是将2的整数幂的数赋给threshold**？

•  threshold这个成员变量是阈值，决定了是否要将散列表再散列。它的值应该是：capacity * load factor才对的。

其实这里仅仅是一个初始化，当创建哈希表的时候，它会重新赋值的：

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image160.jpg?lastModify=1630030805)

其他构造方法

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image162.jpg?lastModify=1630030753)



#### 1.2put方法

**核心**

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image164.jpg?lastModify=1630031219)

计算hash值

![image-20210827154953958](img/image-20210827154953958.png)

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image168.jpg?lastModify=1630052980)

我们是根据key的哈希值来保存在散列表中的，我们表默认的初始容量是16，要放到散列表中，就是0-15的位置上。

也就是`tab[i = (n - 1) & hash]`。可以发现的是：在做`&`运算的时候，仅仅是**后4位有效(eg:1110=16  四位)**~  , 那如果我们key的哈希值高位变化很大，低位变化很小。直接拿过去做`&`运算，这就会导致计算出来的Hash值相同的很多。

![img](img/20210417000736912.png)

而设计者**将key的哈希值的高位也做了运算(与高16位做异或运算，使得在做&运算时，此时的低位实际上是高位与低位的结合)，这就增加了随机性**，减少了碰撞冲突的可能性！

具体流程如下：

<img src="file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image170.jpg?lastModify=1630053790" alt="img" style="zoom:150%;" />

新值返回旧值返回测试

<img src="file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image172.jpg?lastModify=1630053973" alt="img" style="zoom:150%;" />

接下来我们看看resize()方法，在初始化的时候要调用这个方法，当散列表元素大于capacity * load factor的时候也是调用resize()

<img src="file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image174.jpg?lastModify=1630054060" alt="img" style="zoom:150%;" />



#### 1.3get方法

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image176.jpg?lastModify=1630055431)



getNode()的具体实现：

<img src="file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image178.jpg?lastModify=1630055565" alt="img" style="zoom:150%;" />

#### 1.4remove方法

<img src="file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image180.jpg?lastModify=1630056042" alt="img" style="zoom:150%;" />

removeNode()的实现：

<img src="file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image182.jpg?lastModify=1630056066" alt="img" style="zoom:150%;" />

### 2.HashMap与HashTable对比

​		从存储结构和实现来讲基本上都是相同的。它和HashMap的最大的不同是它是线程安全的，另外它不允许key和value为null。Hashtable是个过时的集合类，不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image184.jpg?lastModify=1630056927)

### 3.HashMap总结

在JDK8中HashMap的底层是：**数组+链表(散列表)+红黑树**

在散列表中有装载因子这么一个属性，当装载因子*初始容量小于散列表元素时，该散列表会再散列，扩容2倍！

装载因子的**默认值是0.75**，无论是初始大了还是初始小了对我们HashMap的性能都不好

- 装载因子初始值大了，可以减少散列表再散列(扩容的次数)，但同时会导致散列冲突的可能性变大(**散列冲突也是耗性能的一个操作，要得操作链表(红黑树)**！
- 装载因子初始值小了，可以减小散列冲突的可能性，但同时扩容的次数可能就会变多！

初始容量的**默认值是16**，它也一样，无论初始大了还是小了，对我们的HashMap都是有影响的：

- 初始容量过大，那么遍历时我们的速度就会受影响~
- 初始容量过小，散列表再散列(扩容的次数)可能就变得多，扩容也是一件非常耗费性能的一件事~

从源码上我们可以发现：HashMap并不是直接拿key的哈希值来用的，它会将key的哈希值的高16位进行异或操作，使得我们将元素放入哈希表的时候**增加了一定的随机性**。

还要值得注意的是：**并不是桶子上有8位元素的时候它就能变成红黑树，它得同时满足我们的散列表容量大于64才行的**~

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image186.jpg?lastModify=1630057035)

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image188.jpg?lastModify=1630057048)



## 五、LinkedHashMap

类的继承图

<img src="file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image193.jpg?lastModify=1630057160" alt="img" style="zoom:150%;" />

<img src="file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image195.jpg?lastModify=1630493911" alt="img" style="zoom:150%;" />

总结出LinkedHashMap几点：

•      底层是散列表和双向链表

•      允许为null，不同步

•      插入的顺序是有序的(底层链表致使有序)

•      装载因子和初始容量对LinkedHashMap影响是很大的~

同时也给我带了几个疑问：

•      access-ordered和insertion-ordered具体的使用和意思

•      为什么说初始容量对遍历没有影响？

希望可以在看源码的过程中可以解决掉我这两个疑问~~~那接下来就开始吧

### 1.LinkedHashMap

#### 1.1LinkedHash的域

<img src="file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image197.jpg?lastModify=1630494102" alt="img" style="zoom:150%;" />



#### 1.2LinkedHash重写的方法

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image199.jpg?lastModify=1630891297)

这就印证了我们的LinkedHashMap**底层确确实实是散列表和双向链表**~

•      在构建新节点时，构建的是LinkedHashMap.Entry 不再是Node.



#### 1.3构造方法

默认有五个构造方法

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image201.jpg?lastModify=1630892142)

<img src="file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image203.jpg?lastModify=1630892176" alt="img" style="zoom:150%;" />

默认使用的是插入顺序



#### 1.4put方法

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image204.png?lastModify=1630892672)

再顿了一下，原来LinkedHashMap和HashMap的put方法是一样的！LinkedHashMap继承着HashMap，LinkedHashMap没有重写HashMap的put方法

所以，LinkedHashMap的put方法和HashMap是一样的。

当然了，**在创建节点的时候，调用的是**LinkedHashMap**重写的方法**~

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image206.jpg?lastModify=1630892755)



#### 1.5get方法

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image208.jpg?lastModify=1630893064)

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image210.jpg?lastModify=1630893326)

get方法也是多了：**判断是否为访问顺序**~~~

讲到了这里，感觉我们可以简单测试一波了：

首先我们来看看已**插入顺序**来进行插入和遍历：

```java
public static void insertOrder() {

     *//* *默认是插入顺序*
     LinkedHashMap<Integer,String> insertOrder = new LinkedHashMap();
     
     String value = "jerry";
     int i = 0;
     
     insertOrder.put(i++, value);
     insertOrder.put(i++, value);
     insertOrder.put(i++, value);
     insertOrder.put(i++, value);
     insertOrder.put(i++, value);
     
     *//**遍历*
     Set<Integer> set = insertOrder.keySet();
     for (Integer s : set) {
       String mapValue = insertOrder.get(s);
       System.out.println(s + "---" + mapValue);
     }

   }
```

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image212.jpg?lastModify=1630893406)

接着，我们来测试一下以**访问顺序**来进行插入和遍历：

```
  public static void accessOrder() {
     *//* *设置为访问顺序的方式*
     LinkedHashMap<Integer,String> accessOrder = new LinkedHashMap(16, 0.75f, true);

     String value = "关注公众号Java3y";
     int i = 0;
     accessOrder.put(i++, value);
     accessOrder.put(i++, value);
     accessOrder.put(i++, value);
     accessOrder.put(i++, value);
     accessOrder.put(i++, value);

 



     *//* *遍历*
     Set<Integer> sets = accessOrder.keySet();
     for (Integer key : sets) {
       String mapValue = accessOrder.get(key);
       System.out.println(key + "---" + mapValue);
     }

   }
```

代码**看似**是没有问题，但是运行会出错的！

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image214.jpg?lastModify=1630893461)

前面在看源码注释的时候我们就发现了：**在****AccessOrder**的情况下，使用get方法也是结构性的修改**！

为了简单看出他俩的区别，下面我就直接用key来进行看了~

以下是**访问顺序的测试**：

```
public static void accessOrder() {
     *//* *设置为访问顺序的方式*
     LinkedHashMap<Integer,String> accessOrder = new LinkedHashMap(16, 0.75f, true);

     String value = "关注公众号Java3y";
     int i = 0;
     accessOrder.put(i++, value);
     accessOrder.put(i++, value);
     accessOrder.put(i++, value);
     accessOrder.put(i++, value);
     accessOrder.put(i++, value);

 



     *//* *访问一下key**为3**的元素再进行遍历*
     accessOrder.get(3);
     
     *//* *遍历*
     Set<Integer> sets = accessOrder.keySet();
     for (Integer key : sets) {
     
       System.out.println(key );
     }

   }
```

测试结果：

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image216.jpg?lastModify=1630893700)

以下是**插入顺序的测试**(代码就不贴了，和上面几乎一样)：

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image218.jpg?lastModify=1630893731)

我们可以这样理解：**最常用的将其放在链表的最后，不常用的放在链表的最前**~

这个知识点以我的理解而言，它这个**访问顺序在**LinkedHashMap**如果不重写用处并不大**~它是用来给别的实现进行**扩展**的

•      **因为最常被使用的元素再遍历的时候却放在了最后边，在LinkedHashMap**中我也没找到对应的方法来进行调用~

•      一个removeEldestEntry(Map.Entry<K,V> eldest)方法，**重写它可以删除最久未被使用的元素**！！

•      还有一个是afterNodeInsertion(boolean evict)方法，**新增时判断是否需要删除最久未被使用的元素**！！

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image220.png?lastModify=1630893767)



#### 1.6remove方法

对于remove方法，在LinkedHashMap中也没有重写，它调用的还是父类的HashMap的remove()方法，在LinkedHashMap中重写的是：afterNodeRemoval(Node<K,V> e) 这个方法

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image222.jpg?lastModify=1630893824)

当然了，在remove的时候会涉及到上面重写的方法：

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image224.jpg?lastModify=1630893866)



#### 1.7遍历的方法

Set<Map.Entry<K,V>> entrySet()是被重写的了

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image226.jpg?lastModify=1630893890)

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image228.jpg?lastModify=1630893899)

看到了这里，我们就知道为啥注释说：**初始容量对遍历没有影响**

因为它遍历的是**LinkedHashMap**内部维护的一个双向链表，而不是散列表(当然了，链表双向链表的元素都来源于散列表)



### 2.LinkedHashMap总结

LinkedHashMap比HashMap多了一个双向链表的维护，在数据结构而言它要复杂一些，阅读源码起来比较轻松一些，因为大多都由HashMap实现了..

阅读源码的时候我们会发现多态是无处不在的~子类用父类的方法，子类重写了父类的**部分**方法即可达到不一样的效果！

•      比如：LinkedHashMap并没有重写put方法，而put方法内部的newNode()方法重写了。LinkedHashMap调用父类的put方法，里面回调的是重写后的newNode()，从而达到目的！

LinkedHashMap可以设置两种遍历顺序：

•      访问顺序（access-ordered）

•      插入顺序（insertion-ordered）

•      **默认是插入顺序的**

对于访问顺序，它是LRU(最近最少使用)算法的实现，要使用它要么**重写**LinkedListMap**的几个方法**(removeEldestEntry(Map.Entry<K,V> eldest)和afterNodeInsertion(boolean evict))，要么是**扩展**成LRUMap来使用，不然设置为访问顺序（access-ordered）的用处不大~

**LinkedHashMap**遍历的是内部维护的双向链表，所以说初始容量对LinkedHashMap遍历是不受影响的



## 六、TreeMap





















## 七、Set集合

## 八、CopyOnWriteArrayList

## 九、常见问题



















# 3.异常

![image-20210224100129604](file://D:\FolkKnowledge\Company_interview_question\Question\img\image-20210224100129604.png?lastModify=1627636882)



# 4.泛型











# 5.反射















# 6.注解



# 7.I/O



# 8.图形化（Swing）



# 9.JAVA关键字


一、break ,continue ,return 的区别及作用

break 跳出总上一层循环，不再执行循环(结束当前的循环体)
continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)
return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)