# 1.接口

在接口里面定义一个抽象方法

```java
//创建一接口
package a;//创建一个包，名字为a
public interface aaa1
{
	public int getMax();//创建一个接口方法getMax,都是出现方法需要实现接口然后重写
	String getMes();//创建一个接口方法getMex
}
```

```java
package a;//创建一个包，名字为a
//开发使用该接口的类
import a.aaa1;//引用接口的包
public class test implements aaa1 //test类描述的是实现接口的方法
{
	public int getMax()//实现接口里的方法
	{
		int i=123;
		return i;
	}
	public String getMes()//实现接口里的方法
	{
		String s="实现接口里的方法";
		return s;
	}
	public static void main (String[]args)
	{
		test t=new test();//创建test类的实例对象
		int i=t.getMax();//实现了接口里的方法并进行调用
		String s=t.getMes();
		System.out.println(i);
		System.out.println(s);
	}

}


```

# 2.容器总结(集合)

**先了解一下散列表和红黑树**

![preview](img/v2-d5273c0d3dd4659cc621c8461ee3879c_r.jpg)

![img](img/20190514220736591.png)

AVL 树是又叫平衡二叉树，平衡二叉树递归定义如下：

1. 左右子树的高度差小于等于 1。

2. 其每一个子树均为平衡二叉树。

AVL树的左旋与右旋 https://blog.csdn.net/qq_25806863/article/details/74755131

## 红黑树

![img](file://D:\FolkKnowledge\Company_interview_question\Question\img\clipboard-1614080911857.png?lastModify=1627628727)

但是红黑树的性质是每条路径的黑色节点数目相同这个时候你再想想那其他路径的黑色节点数目一定比你现在少一个节点，所以调整起来是非常繁琐的. 插入红节点不需要调整其他路径，如果它的父亲为黑，那么直接插入，如果他的父亲为红那么在该路径上面开始分情况调整. 所以插入节点默认颜色一定要为红.如果为黑调节成本太大了.

## 散列表（HASH表）

数组的特点是：寻址容易，插入和删除困难；

而链表的特点是：寻址困难，插入和删除容易。

那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表，哈希表有多种不同的实现方法，我接下来解释的是最常用的一种方法——拉链法，我们可以理解为“链表的数组”，如图：

![img](img/20160603152626346)

​                                                                                         hash表的应用（拉链法）

解决散列冲突通常有以下几种方法：

- 拉链法

- 开放定址法

  **线性探测法**

  如果此时再要插入20，则20 % 7 = 6，但是6的位置已有元素，因此探测下一个位置（6+1）%7，在这里就是下标为0的位置。

  但这种方式的一个问题是，可能造成**一次聚集**，因为一旦冲突发生，为了处理冲突就会占用下一个位置，而如果冲突较多时，就会出现数据都**聚集在一块区域**。这样就会导致任何关键字都需要多次尝试才可能解决冲突。

  **平方探测法**

  顾名思义，如果说前面的探测函数是F（i）= i % 7，那么平方探测法就是F（i）= (i^2 )% 7。
  但是这也同样会产生**二次聚集**问题。

  **双散列**

  为了**避免聚集**，在探测时选择跳跃式的探测，即再使用一个散列函数，用来计算探测的位置。假设前面的散列函数为hash1(X)，用于探测的散列函数为hash2(X)，那么一种流行的选择是F(i) = i * hash2(X)，即第一次冲突时探测hash1(X)+hash2(X)的位置，第二次探测
  hash1(X)+2hash2(X)的位置。

  可以看到，无论是哪种开放定址法，它都要求表足够大。

- 再散列

  散列表可以认为是具有固定大小的数组，那么如果插入新的数据时散列表已满，或者散列表所剩容量不多该怎么办？这个时候就需要再散列，常见做法是，建立一个是原来两倍大小的散列表，将原来表中的关键字重新散列到新表中。

- ...

**散列表的应用**

文件校验或数字签名。当然还有快速查询功能的实现。例如，redis中的字典结构就使用了散列表，使用**MurmurHash算法**来计算字符串的hash值，并采用**拉链法**处理冲突，当散列表的**装载因子**（关键字个数与散列表大小的比）接近某个大小时，进行**再散列**。

一个设计良好的散列表能够几乎在O（1）时间复杂度内完成插入，删除和查找，但前提是**散列函数设计得足够优雅，以及有着合适散列冲突解决方案**。



![img](file://D:\LocalRepositories\OriginRepositories\JavaNote\%E5%90%8E%E7%AB%AF%E8%B7%AF%E7%BA%BF\1.%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80\1.Java%E8%AF%AD%E8%A8%80\img\20190213131312518.png?lastModify=1627637177)

<img src="img/image-20210730174352638.png" alt="image-20210730174352638" style="zoom:80%;" />



## 一、Collection

<img src="img/1628e4e1f75125d8" alt="img" style="zoom: 67%;" />

### 1、迭代器(Iterator)介绍

**遍历集合(Collection)的元素都可以使用Iterator**，至于它的具体实现是以内部类的方式实现的！

```java
  hasNext()、next()、remove()

  hasNext:没有指针下移操作，只是判断是否存在下一个元素

  next:指针下移，返回该指针所指向的元素

  remove:删除当前指针所指向的元素，一般和next方法一起用，这时候的作用就是删除next方法返回的元素
      
  nextLine():不会忽略一些字符如空格等。
  next():会忽略一些字符，只记录有效字符。

```



<img src="img/1628e4e2686de25a" alt="img" style="zoom:150%;" />

### 2、List与Set常用子类及介绍

**List集合常用的子类有三个：**

•      ArrayList

–     底层数据结构是数组。线程不安全

•      LinkedList

–     底层数据结构是链表。线程不安全

•      Vector

–     底层数据结构是数组。线程安全



 **Set集合的特点是：元素不可重复，常用子类有**

•      HashSet集合

–     A:底层数据结构是哈希表(是一个元素为链表的数组) 

•      TreeSet集合

–     A:底层数据结构是红黑树(是一个自平衡的二叉树)

–     B:保证元素的排序方式

•      LinkedHashSet集合 

–     A:：底层数据结构由哈希表和链表组成。



## 二、List集合

### 1、ArrayList解析

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image056.jpg?lastModify=1629799861)

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image058.jpg?lastModify=1629799933)

#### 1.1构造方法

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image060.jpg?lastModify=1629801960)

#### 1.2add方法

**add(E e)**

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image062.jpg?lastModify=1629873205)

•      **确认list容量，尝试容量加1，看看有无必要**

•      **添加元素**

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image064.jpg?lastModify=1629874010)

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image066.jpg?lastModify=1629874023)

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image068.jpg?lastModify=1629874040)

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image070.jpg?lastModify=1629874054)

到目前为止，我们就可以知道add(E e)的基本实现了：

•      首先去检查一下数组的容量是否足够

–     足够：直接添加

–     不足够：扩容

•      扩容到原来的1.5倍

•      第一次扩容后，如果容量还是小于minCapacity，就将容量扩充为minCapacity。



**add(int index, E element)**

步骤：

•      **检查角标**

•      **空间检查，如果有需要进行扩容**

•      **插入元素**

![标题: fig:](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image072.png?lastModify=1629874258)

我们发现，与扩容相关ArrayList的add方法底层其实都是arraycopy()来实现的

看到arraycopy()，我们可以发现：该方法是由C/C++来编写的，并不是由Java实现：

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image074.jpg?lastModify=1629874319)

本地Native方法非常有用，因为它有效地扩充了jvm.事实上，我们所写的java代码已经用到了本地方法，在sun的java的并发（多线程）的机制实现中，许多与操作系统的接触点都用到了本地方法，这使得java程序能够超越java运行时的界限。有了本地方法，java程序可以做任何应用层次的任务。

#### 1.3get方法

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image076.jpg?lastModify=1629874393)



```java
 //检查角标
 private void rangeCheck(int index) {
  if (index >= size)
   throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
 }

 //返回元素
 E elementData(int index) {
  return (E) elementData[index];
 }
```

#### 1.4set方法

​				•      **检查角标**

​				•      **替代元素**

​				•      **返回旧值**

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image078.jpg?lastModify=1629874628)

#### 1.5remove方法

•      **检查角标**

•      **删除元素**

•      **计算出需要移动的个数，并移动**

•      **设置为null，让Gc回收**

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image080.jpg?lastModify=1629874713)



#### 1.6其他一些细节

•      ArrayList是**基于动态数组实现的**，在**增删时候，需要数组的拷贝复制**。

•      ArrayList的默认初始化容量是10，每次扩容时候增加原先容量的一半，也就是变为原来的1.5**倍**

•      删除元素时不会减少容量，**若希望减少容量则调用trimToSize()**。

•      它不是线程安全的。它能存放null值。

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image082.jpg?lastModify=1629875006)

### 2、Vector vs ArrayList?

Vector是jdk1.2的类了，比较老旧的一个集合类。

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image085.jpg?lastModify=1629876238)

Vector底层也是数组，与ArrayList最大的区别就是：**同步(线程安全)**

Vector是同步的，我们可以从方法上就可以看得出来~

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image087.jpg?lastModify=1629876601)

在要求非同步的情况下，我们一般都是使用ArrayList来替代Vector的了~

如果想要ArrayList实现同步，可以使用Collections的方法：**List list = Collections.synchronizedList(new ArrayList(...));**就可以实现同步了~

还有另一个区别：

•      **ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector是扩展1倍。**

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image089.jpg?lastModify=1629876661)

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image091.jpg?lastModify=1629876668)

### 3、LinkedList解析

LinkedList底层是**双向链表**

单向链表：只有一个指向下一个节点的指针。

优点：单向链表增加删除节点简单。遍历时候不会死循环；

缺点：只能从头到尾遍历。只能找到后继，无法找到前驱，也就是只能前进。

适用于节点的增加删除。

 

双向链表：有两个指针，一个指向前一个节点，一个后一个节点。

优点：可以找到前驱和后继，可进可退；

缺点：增加删除节点复杂，需要多分配一个指针存储空间。

适用于需要双向查找节点值的情况。


![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image093.jpg?lastModify=1629876702)

从结构上，我们还看到了**LinkedList**实现了Deque接口，因此，我们可以操作LinkedList像操作队列和栈一样~

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image096.png?lastModify=1629877423)

LinkedList变量就这么几个，因为我们操作单向链表的时候也发现了：有了头结点，其他的数据我们都可以获取得到了。(双向链表也同理)

#### 3.1构造方法

构造方法有两个：

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image100.jpg?lastModify=1629877643)

#### 3.2add方法

```java
//add方法实际上就是往链表最后添加元素

   public boolean add(E e) {
     linkLast(e);
     return true;
   }
   void linkLast(E e) {
     final Node<E> l = last;
     final Node<E> newNode = new Node<>(l, e, null);
     last = newNode;
     if (l == null)
       first = newNode;
     else
       l.next = newNode;
     size++;
     modCount++;
   }
```

#### 3.3get方法

我们进去看一下具体的实现是怎么样的：

可以看到get方法实现就两段代码：

```java
 public E get(int index) {
     checkElementIndex(index);
     return node(index).item;
   }
```

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image108.jpg?lastModify=1629878494)



#### 3.4set方法

```java
//set方法和get方法其实差不多，**根据下标来判断是从头遍历还是从尾遍历**

  public E set(int index, E element) {
     checkElementIndex(index);
     Node<E> x = node(index);
     E oldVal = x.item;
     x.item = element;
     return oldVal;
   }
```



#### 3.5remove方法

![img](file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image102.jpg?lastModify=1629877892)`

<img src="file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image104.jpg?lastModify=1629877932" alt="img" style="zoom:67%;" />

<img src="file://C:\Users\%E5%BE%90%E7%BA%AA%E4%BC%9F\Desktop\img\clip_image106.jpg?lastModify=1629877853" alt="img" style="zoom:67%;" />





### 4、List集合总结

**ArrayList**：

•      底层实现是数组

•      ArrayList的默认初始化容量是10，每次扩容时候增加原先容量的一半，也就是变为原来的1.5倍

•      在**增删时候，需要数组的拷贝复制(navite 方法由C/C++实现)**

**LinkedList**：

•      底层实现是**双向链表**[双向链表方便实现往前遍历

**Vector**：

•      底层是数组，现在已少用，被ArrayList替代，原因有两个：

–     Vector所有方法都是同步，**有性能损失**。

–     Vector初始length是10 超过length时 以100%比率增长，**相比于ArrayList更多消耗内存**。

**总的来说：查询多用ArrayList，增删多用LinkedList**。

**ArrayList**增删慢不是绝对的(在数量大的情况下，已测试)：

•      如果增加元素一直是使用add()(增加到末尾)的话，那是ArrayList要快

•      一直删除末尾的元素也是ArrayList要快【不用复制移动位置】

•      至于如果删除的是中间的位置的话，还是ArrayList！

但一般来说：**增删多还是用LinkedList**，因为上面的情况是极端的~



## 三、Map集合



















## 四、HashMap

## 五、LinkedHashMap

## 六、TreeMap

## 七、Set集合

## 八、CopyOnWriteArrayList

## 九、常见问题



















# 3.异常

![image-20210224100129604](file://D:\FolkKnowledge\Company_interview_question\Question\img\image-20210224100129604.png?lastModify=1627636882)



















# 4.泛型











# 5.反射















# 6.注解



# 7.I/O



# 8.图形化（Swing）



# 9.JAVA关键字


一、break ,continue ,return 的区别及作用

break 跳出总上一层循环，不再执行循环(结束当前的循环体)
continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)
return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)